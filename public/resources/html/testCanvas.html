<!DOCTYPE html>
<html>
   <head>
      <meta charset = "utf-8">
      <title>jQuery UI Widget - Default functionality</title>
      <link rel = "stylesheet" href = "//code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css">
      <script src = "https://code.jquery.com/jquery-1.10.2.js"></script>
      <script src = "https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
      <script src = "../../lib/js/jcanvas.min.js"></script>

      <script>
         $(function() {
        	 
var PokerTable1 = function(params) {
}
$.extend(PokerTable1.prototype, {
	area: function() {
		console.log('area');
	},
	diameter: function() {
		console.log('diameter');
	}	
});

var p = new PokerTable1();
p.area();

$.widget("custom.pokertable", {
	options: {
		x: 255,
		y: 200
	},
	_init: function() {
		console.log('init');
		this.refresh();
	},
	_setOption: function( key, value ) {
		this._super( key, value );
	},
	_setOptions: function( options ) {
		this._super( options );
		this.refresh();
	},
	refresh: function() {
		console.log('refresh');
		//var progress = this.options.value + "%";
		//this.element.text( progress );
		//if ( this.options.value == 100 ) {
       //     this._trigger( "complete", null, { value: 100 } );
        //}
	},
    
	
	_create: function() {
		console.log('create');
	},
	_destroy: function() {
		console.log('destory');
	},
	hi: function() {
		console.log('hi');
	},
	draw: function(a,b,c,d,e) {
		console.log('draw');
	},
	paintSelf: function() {
		var element = this.element[0];
		var ctx = element.getContext("2d");
		this._drawTableLayer('canvas.' + element.id, 0, 0, element.scrollWidth, element.scrollHeight);
		
		
		//$.each(this.element, function (index, canvas) {
			//this;
			//value;
			//outside;
			
			
			//console.log(value + '    :   ' + value.id);
			//console.log(value.scrollWidth + " " + value.scrollHeight);
			//console.log('paintSelf' + $(value).attr('id'));
			
			//drawTableLayer('canvas.' + this.element.id, 0, 0, this.element.scrollWidth, this.element.scrollHeight);
		//});
	},
	_drawTableLayer: function(canvasId, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight) {
		this._drawTableLayer_Angle(canvasId, 0, 2.5*Math.PI, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight);
	},
	_drawTableLayer_Angle: function(canvasId, startAngle, stopAngle, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight) {	

		var leftCenter=null, rightCenter=null, topCenter=null, bottomCenter=null;
		if (tableWidth > tableHeight) {
			var middle = tableHeight / 2;
			leftCenter  = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
			rightCenter = this._createRadiusPoint(tableTopLeft_x + tableWidth - middle, tableTopLeft_y + middle, middle);
		} else if (tableWidth < tableHeight) {
			var middle = tableWidth / 2;
			topCenter    = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
			bottomCenter = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + tableHeight - middle, middle);
		} else {
			// circle
			var middle = tableWidth / 2;
			leftCenter  = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
			rightCenter = this._createRadiusPoint(tableTopLeft_x + tableWidth - middle, tableTopLeft_y + middle, middle);
			topCenter    = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
			bottomCenter = this._createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + tableHeight - middle, middle);
		}
		
		
		if (leftCenter != null) {
			this._ringTable_drawCurvedEnd(canvasId, leftCenter, startAngle, stopAngle, 0.5*Math.PI, 1.5*Math.PI);
		}
		if (rightCenter != null) {
			this._ringTable_drawCurvedEnd(canvasId, rightCenter, startAngle, stopAngle, 1.5*Math.PI, 2.5*Math.PI);
		}
		if (bottomCenter != null) {
			this._ringTable_drawCurvedEnd(canvasId, bottomCenter, startAngle, stopAngle, 0, Math.PI);
		}
		if (topCenter != null) {
			this._ringTable_drawCurvedEnd(canvasId, topCenter, startAngle, stopAngle, Math.PI, 2*Math.PI);
		}
		if (topCenter == null) { 
			this._ringTable_drawStraightSides(canvasId, leftCenter.x, tableTopLeft_y, rightCenter.x - leftCenter.x, tableHeight, true);
		}
		if (leftCenter == null) {
			this._ringTable_drawStraightSides(canvasId, tableTopLeft_x, topCenter.y, tableWidth, bottomCenter.y - topCenter.y, false);
		}
	},
	_createRadiusPoint: function(x, y, r) {
		return { 'x': x, 'y': y, 'r': r };
	},
	/**
	 * canvasId - In the form 'canvas' + 'canvas_class'.  For instance, 'canvas.ringTableOne'
	 * centerRadial - pivit center of the curve.  Expecting centerRadial.x, centerRadial.y, centerRadial.r 
	 * startAngle - In radians, starting angle of what we are drawing at high level.  If it falls outside of this sector's responsibility nothing is drawn.
	 * stopAngle  - In radians, starting angle of what we are drawing at high level.  If it falls outside of this sector's responsibility nothing is drawn.
	 * responsibilityStartAngle - In radians, the starting angle of this sector.  We are only responsible to draw in this sector.  This is done to provide different gradients across different parts of the table for lighting/perspectives.
	 * responsibilityStopAngle  - In radians, the stopping angle of this sector.  We are only responsible to draw in this sector.  This is done to provide different gradients across different parts of the table.
	 *
	 */
	 _ringTable_drawCurvedEnd: function (canvasId, centerRadial, startAngle, stopAngle, responsibilityStartAngle, responsibilityStopAngle) {
		var cushionLen = 30;
		
		var grad = $(canvasId).createGradient({
			x1: centerRadial.x, y1: centerRadial.y,
			x2: centerRadial.x, y2: centerRadial.y,
			r1: centerRadial.r, r2: centerRadial.r - cushionLen,
			c1: 'rgba(255, 0, 0, 0.75)',
			c2: '#000', s2: 0.2,
			c3: '#000', s3: 0.8,
			c4: 'rgba(255, 0, 0, 0.75)'
	    });
		
		if (this._ringTable_isDebuggingTable()) {
			// Draw the circle center for debugging
			$(canvasId).drawArc({
				fillStyle: grad,
				layer: true,
				x: centerRadial.x, y: centerRadial.y,
				radius: 5
			});
		}
		
		var isOurSectorResponsibleToDraw = true;
		if (startAngle > responsibilityStopAngle) {
			isOurSectorResponsibleToDraw = false;
		}
		if (stopAngle < responsibilityStartAngle) {
			isOurSectorResponsibleToDraw = false;
		}
		
		if (isOurSectorResponsibleToDraw) {
			var minStartAngle = Math.max(responsibilityStartAngle, startAngle);
			var maxStopAngle  = Math.min(responsibilityStopAngle, stopAngle);
			var self = this;
			$(canvasId).draw({
				layer: true,
				fn: function(ctx) {
					var innerRadius = centerRadial.r - cushionLen;
					if (innerRadius < 0) {
						console.error('cushion length is too large for canvas dimensions');
						innerRadius = 1;
					}
					
					if (self._ringTable_isDebuggingTable()) {
						ctx.strokeStyle = '#000';
						ctx.strokeWidth = 2;	
					} else {
						ctx.fillStyle = grad;	
					}
					
					ctx.beginPath();
					ctx.arc(centerRadial.x, centerRadial.y, centerRadial.r, minStartAngle, maxStopAngle);
					ctx.lineTo(centerRadial.x - Math.cos(maxStopAngle - Math.PI) * innerRadius, centerRadial.y - Math.sin(maxStopAngle - Math.PI) * innerRadius);  
					ctx.arc(centerRadial.x, centerRadial.y, innerRadius, maxStopAngle, minStartAngle, true);
					ctx.lineTo(centerRadial.x - Math.cos(minStartAngle - Math.PI) * centerRadial.r, centerRadial.y - Math.sin(minStartAngle - Math.PI) * centerRadial.r);
					
					if (self._ringTable_isDebuggingTable()) {
						ctx.stroke();
					} else {
						ctx.fill();
					}
				}
			});
		}	
	},
	/**
	 * Draws the straight poritions of the rail/cushion which are simply rectangles.
	 *
	 *
	 */
	 _ringTable_drawStraightSides: function(canvasId, topLeft_x, topLeft_y, theWidth, theHeight, isTopAndBottomRail) {
		var cushionLen = 30;
		var selfVal = this;

		if (isTopAndBottomRail) {
			// top cushion
			$(canvasId).drawRect( this._private_ringTable_createDrawStraightSides_Params({
				x: topLeft_x + theWidth/2, 
				y: topLeft_y + cushionLen/2,
				width: theWidth,
				height: cushionLen,
				data: { isVertical: false, 'canvasSelector': canvasId, self: selfVal }				
			}));
			// bottom cushion
			$(canvasId).drawRect( this._private_ringTable_createDrawStraightSides_Params({
				x: topLeft_x + theWidth/2, 
				y: (theHeight - cushionLen) + cushionLen/2,
				width: theWidth,
				height: cushionLen,
				data: { isVertical: false, 'canvasSelector': canvasId, self: selfVal }
			}));
		} else {
			// left cushion
			$(canvasId).drawRect( this._private_ringTable_createDrawStraightSides_Params({
				x: topLeft_x + cushionLen / 2, 
				y: topLeft_y + theHeight / 2,
				width: cushionLen,
				height: theHeight,
				data: { isVertical: true, 'canvasSelector': canvasId, self: selfVal }
			}));
			// right cushion
			$(canvasId).drawRect( this._private_ringTable_createDrawStraightSides_Params({
				x: topLeft_x + theWidth - cushionLen + (cushionLen/2), 
				y: topLeft_y + theHeight/2,
				width: cushionLen,
				height: theHeight,
				data: { isVertical: true, 'canvasSelector': canvasId, self: selfVal }			
			}));
		}
	},
	_ringTable_isDebuggingTable: function() {
		return false;
	},
	_private_ringTable_createDrawStraightSides_Params: function(params) {
		params.layer = true;
		if (this._ringTable_isDebuggingTable()) {
			params.strokeStyle = '#000';
			params.strokeWidth = 2;
		} else {
			params.fillStyle = this._linearFillCallback;
		}
		
		return params;
	},
	_getValue: function(selector, property, defaulValue) {
		var val = $(selector).css(property);
		if (val == undefined) {
			val = defaulValue;
		}
		return val;
	},
	// This creates the gradient for the straight part of the rail cushion
	// We expect layer to have a layer.data.isVertical, layer.data.canvasSelector
	// Exists outside this (like a static methof)
	// Might exist outside this
	_linearFillCallback: function (layer) {
		
		var cushionPrimary = layer.data.self._getValue(layer.data.canvasSelector, 'cushionPrimary', '#000');
		var cushionFade = layer.data.self._getValue(layer.data.canvasSelector, 'cushionFade', 'rgba(255, 0, 0, 0.75)');
		
		var params = {
				c1: cushionFade,
				c2: cushionPrimary, s2: 0.2,
				c3: cushionPrimary, s3: 0.8,
				c4: cushionFade				
		};
		if (layer.data.isVertical) {
			params.x1 = layer.x - layer.width/2;
			params.x2 = layer.x + layer.width/2;
			params.y1 = layer.y;
			params.y2 = layer.y;
		} else {
			params.x1 = layer.x;
			params.x2 = layer.x;
			params.y1 = layer.y - layer.height/2;
			params.y2 = layer.y + layer.height/2;
		}
		return $(this).createGradient(params);
	}
	
});

/**
var c = $("#canvas6").pokertable({  
	
});
c.pokertable("hi");
c.pokertable("paintSelf");
c.draggable( {
	//containment: '#canvas5 #canvas6',
	//cursor: 'move',
	//snap: '#canvas5'
});
*/
//c.attr("x", 50);
//c.pokertable("hi");

        	 
        	 /**
            $.widget("iP.myButton", {
               _create: function() { 
                  this._button = $("<button>"); 
                  this._button.text("My first Widget Button");
                  this._button.width(this.options.width) 
                  this._button.css("background-color", this.options.color);    
                  this._button.css("position", "absolute");   
                  this._button.css("left", "100px");            
                  $(this.element).append(this._button);
               },
         
               move: function(dx) { 
                  var x = dx + parseInt(this._button.css("left")); 
                  this._button.css("left", x); 
                  if(x>400) { this._trigger("outbounds",{},  {position:x}); }
               }
            });
            $("#button3").myButton();
            $("#button3").myButton("move", 200);
            //$("#button3").myButton("disable");
                  
            
         $("canvas").drawPolygon({
          	  draggable: true,
          	  fillStyle: "#6c3",
          	  x: 100, y: 100,
          	  radius: 50, sides: 5,
          	  layer: true
          	});
         
			$('canvas').draw({
					fn : function(ctx) {
						ctx.fillStyle = '#333';
						ctx.fillRect(50, 50, 100, 100);
					},
					 layer: true
				});
			
        */ 
        
//canvas1.control
/**
		

         
         drawTableLayer('canvas.canvas2', 0, 0, document.getElementById('canvas2').scrollWidth, document.getElementById('canvas2').scrollHeight);
         drawTableLayer('canvas.canvas3', 0, 0, document.getElementById('canvas3').scrollWidth, document.getElementById('canvas3').scrollHeight);
         drawTableLayer('canvas.canvas4', 0, 0, document.getElementById('canvas4').scrollWidth, document.getElementById('canvas4').scrollHeight);
         drawTableLayer('canvas.canvas5', 0, 0, document.getElementById('canvas5').scrollWidth, document.getElementById('canvas5').scrollHeight);
 */
 
	createTablePropertyControl({
		id: 'canvasWithControl1',
		height: 400,
		width: 800
	});
	createTablePropertyControl({
		id: 'canvasWithControl2',
		height: 800,
		width: 400
	});
	createTablePropertyControl({
		id: 'canvasWithControl3',
		height: 400,
		width: 400
	});
	createTablePropertyControl({
		id: 'canvasWithControl4',
		height: 300,
		width: 1300
	});
	createTablePropertyControl({
		id: 'canvasWithControl5',
		height: 1300,
		width: 300
	});
	createTablePropertyControl({
		id: 'canvasWithControl6',
		height: 100,
		width: 200
	});
});
         
function updateCss(selector, textAreaId) {
	var textVal = $('#' + textAreaId).val();
	var json = eval("(" + textVal + ")");
	$(selector).css(json);
	
	//var val = $(selector).css('--fake');
	//console.log(val);
}

var globalCanvasMap = {};
 
function createTablePropertyControl(parms) {
	//var htmlHeader = parms.header;
	//if (htmlHeader != undefined) {
	//	$('#'+parms.id).append(htmlHeader);
	//}
	var textAreaId = parms.id + "TextBox";
	var canvasId = parms.id + "Canvas";
	var div = '#' + parms.id;
	
	//var $ctrl = $('<input/>').attr({type: 'textarea', name: 'textarea', value: 'text\ntyty'}).addClass("textarea");
	//$(div).append($ctrl);
	
	$(div).append()
	
	var ctrl = $("<textarea id='" + textAreaId + "' rows='8' cols='50' />");
	ctrl.text(JSON.stringify(parms, null, 3));
	$(div).append(ctrl);
	
	$(div)
		.append('<div/>')
		.append(
			$('<button/>').text('Update').click(function(event) {
				var divId = this.parentElement.id;
				var textAreaId = divId + "TextBox";
				var canvasId = divId + "Canvas";
				
				var textVal = $('#'+textAreaId).val(); 
				var json = eval("(" + textVal + ")");
				
				// Lets just create a new one
				// Store away the poker object so we can access it globally
				
				$('#'+canvasId).replaceWith(
						$('<canvas/>').attr({ id: canvasId, width: json.width, height: json.height, 'class': canvasId})
				);
				
				globalCanvasMap[divId] = $('#'+canvasId).pokertable(json);
				globalCanvasMap[divId].pokertable("paintSelf");
				
				
		})
	);
	$(div)
		.append('<div/>')
		.append(
			$('<canvas/>').attr({ id: canvasId, width: parms.width, height: parms.height, 'class': canvasId})
	);
	
	// Store away the poker object so we can access it globally
	globalCanvasMap[parms.id] = $('#'+canvasId).pokertable(parms);
	globalCanvasMap[parms.id].pokertable("paintSelf");
	
	//$(div).
	
	/**
	$('#'+parms.id).append("<textarea id='" + textAreaId + "' rows='8'>{\n" + 
		"  width: '" + parms.width + "px',\n" + 
		"  height: '" + parms.height + "px'\n" + 
		"}</textarea>");
	$('#'+parms.id).append("<br><button onclick='updateCss(\"#" + canvasId + "\", \"" + textAreaId + "\")'>Update css</button>")
	$('#'+parms.id).append("<div><canvas id='" + canvasId + "' class='" + canvasId + "' width='800' height='400'></canvas></div>");
	
	drawTableLayer('canvas.' + canvasId, 0, 0, document.getElementById(canvasId).scrollWidth, document.getElementById(canvasId).scrollHeight);
	*/
	//<canvas id="canvas1" class="canvas1" width="800" height="400"></canvas>
	//console.log('yo' + $('#'+ctlId));
	//var b = $('#'+ctlId);
	//$('#'+ctlId).append("<p>hi</p>");
	//console.log($('#'+ctlId).attr("myprop"));
	
}

/**

function drawTableLayer(canvasId, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight) {
	drawTableLayer_Angle(canvasId, 0, 2.5*Math.PI, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight);
}

function _createRadiusPoint(x, y, r) {
	return { 'x': x, 'y': y, 'r': r };
}

function ringTable_isDebuggingTable() {
	return false;
}
         
function drawTableLayer_Angle(canvasId, startAngle, stopAngle, tableTopLeft_x, tableTopLeft_y, tableWidth, tableHeight) {	

	var leftCenter=null, rightCenter=null, topCenter=null, bottomCenter=null;
	if (tableWidth > tableHeight) {
		var middle = tableHeight / 2;
		leftCenter  = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
		rightCenter = _createRadiusPoint(tableTopLeft_x + tableWidth - middle, tableTopLeft_y + middle, middle);
	} else if (tableWidth < tableHeight) {
		var middle = tableWidth / 2;
		topCenter    = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
		bottomCenter = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + tableHeight - middle, middle);
	} else {
		// circle
		var middle = tableWidth / 2;
		leftCenter  = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
		rightCenter = _createRadiusPoint(tableTopLeft_x + tableWidth - middle, tableTopLeft_y + middle, middle);
		topCenter    = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + middle, middle);
		bottomCenter = _createRadiusPoint(tableTopLeft_x + middle, tableTopLeft_y + tableHeight - middle, middle);
	}
	
	
	if (leftCenter != null) {
		ringTable_drawCurvedEnd(canvasId, leftCenter, startAngle, stopAngle, 0.5*Math.PI, 1.5*Math.PI);
	}
	if (rightCenter != null) {
		ringTable_drawCurvedEnd(canvasId, rightCenter, startAngle, stopAngle, 1.5*Math.PI, 2.5*Math.PI);
	}
	if (bottomCenter != null) {
		ringTable_drawCurvedEnd(canvasId, bottomCenter, startAngle, stopAngle, 0, Math.PI);
	}
	if (topCenter != null) {
		ringTable_drawCurvedEnd(canvasId, topCenter, startAngle, stopAngle, Math.PI, 2*Math.PI);
	}
	if (topCenter == null) { 
		ringTable_drawStraightSides(canvasId, leftCenter.x, tableTopLeft_y, rightCenter.x - leftCenter.x, tableHeight, true);
	}
	if (leftCenter == null) {
		ringTable_drawStraightSides(canvasId, tableTopLeft_x, topCenter.y, tableWidth, bottomCenter.y - topCenter.y, false);
	}
}


function _getValue(selector, property, defaulValue) {
	var val = $(selector).css(property);
	if (val == undefined) {
		val = defaulValue;
	}
	return val;
}

// This creates the gradient for the straight part of the rail cushion
// We expect layer to have a layer.data.isVertical, layer.data.canvasSelector
function linearFillCallback(layer) {

	var cushionPrimary = _getValue(layer.data.canvasSelector, 'cushionPrimary', '#000');
	var cushionFade = _getValue(layer.data.canvasSelector, 'cushionFade', 'rgba(255, 0, 0, 0.75)');
	
	var params = {
			c1: cushionFade,
			c2: cushionPrimary, s2: 0.2,
			c3: cushionPrimary, s3: 0.8,
			c4: cushionFade				
	};
	if (layer.data.isVertical) {
		params.x1 = layer.x - layer.width/2;
		params.x2 = layer.x + layer.width/2;
		params.y1 = layer.y;
		params.y2 = layer.y;
	} else {
		params.x1 = layer.x;
		params.x2 = layer.x;
		params.y1 = layer.y - layer.height/2;
		params.y2 = layer.y + layer.height/2;
	}
	return $(this).createGradient(params);
};
**/

/**
 * Common parameters for sides.
 */
 /**
function _private_ringTable_createDrawStraightSides_Params(params) {
	params.layer = true;
	if (ringTable_isDebuggingTable()) {
		params.strokeStyle = '#000';
		params.strokeWidth = 2;
	} else {
		params.fillStyle = linearFillCallback;
	}
	
	return params;
}*/

/**
 * Draws the straight poritions of the rail/cushion which are simply rectangles.
 *
 *
 */ /**
function ringTable_drawStraightSides(canvasId, topLeft_x, topLeft_y, theWidth, theHeight, isTopAndBottomRail) {
	var cushionLen = 30;

	if (isTopAndBottomRail) {
		// top cushion
		$(canvasId).drawRect( _private_ringTable_createDrawStraightSides_Params({
			x: topLeft_x + theWidth/2, 
			y: topLeft_y + cushionLen/2,
			width: theWidth,
			height: cushionLen,
			data: { isVertical: false, 'canvasSelector': canvasId }				
		}));
		// bottom cushion
		$(canvasId).drawRect( _private_ringTable_createDrawStraightSides_Params({
			x: topLeft_x + theWidth/2, 
			y: (theHeight - cushionLen) + cushionLen/2,
			width: theWidth,
			height: cushionLen,
			data: { isVertical: false, 'canvasSelector': canvasId }
		}));
	} else {
		// left cushion
		$(canvasId).drawRect( _private_ringTable_createDrawStraightSides_Params({
			x: topLeft_x + cushionLen / 2, 
			y: topLeft_y + theHeight / 2,
			width: cushionLen,
			height: theHeight,
			data: { isVertical: true, 'canvasSelector': canvasId }
		}));
		// right cushion
		$(canvasId).drawRect( _private_ringTable_createDrawStraightSides_Params({
			x: topLeft_x + theWidth - cushionLen + (cushionLen/2), 
			y: topLeft_y + theHeight/2,
			width: cushionLen,
			height: theHeight,
			data: { isVertical: true, 'canvasSelector': canvasId }			
		}));
	}
} */

/**
 * canvasId - In the form 'canvas' + 'canvas_class'.  For instance, 'canvas.ringTableOne'
 * centerRadial - pivit center of the curve.  Expecting centerRadial.x, centerRadial.y, centerRadial.r 
 * startAngle - In radians, starting angle of what we are drawing at high level.  If it falls outside of this sector's responsibility nothing is drawn.
 * stopAngle  - In radians, starting angle of what we are drawing at high level.  If it falls outside of this sector's responsibility nothing is drawn.
 * responsibilityStartAngle - In radians, the starting angle of this sector.  We are only responsible to draw in this sector.  This is done to provide different gradients across different parts of the table for lighting/perspectives.
 * responsibilityStopAngle  - In radians, the stopping angle of this sector.  We are only responsible to draw in this sector.  This is done to provide different gradients across different parts of the table.
 *
 */ 
/**
function ringTable_drawCurvedEnd(canvasId, centerRadial, startAngle, stopAngle, responsibilityStartAngle, responsibilityStopAngle) {
	var cushionLen = 30;
	
	var grad = $(canvasId).createGradient({
		x1: centerRadial.x, y1: centerRadial.y,
		x2: centerRadial.x, y2: centerRadial.y,
		r1: centerRadial.r, r2: centerRadial.r - cushionLen,
		c1: 'rgba(255, 0, 0, 0.75)',
		c2: '#000', s2: 0.2,
		c3: '#000', s3: 0.8,
		c4: 'rgba(255, 0, 0, 0.75)'
    });
	
	if (ringTable_isDebuggingTable()) {
		// Draw the circle center for debugging
		$(canvasId).drawArc({
			fillStyle: grad,
			layer: true,
			x: centerRadial.x, y: centerRadial.y,
			radius: 5
		});
	}
	
	var isOurSectorResponsibleToDraw = true;
	if (startAngle > responsibilityStopAngle) {
		isOurSectorResponsibleToDraw = false;
	}
	if (stopAngle < responsibilityStartAngle) {
		isOurSectorResponsibleToDraw = false;
	}
	
	if (isOurSectorResponsibleToDraw) {
		var minStartAngle = Math.max(responsibilityStartAngle, startAngle);
		var maxStopAngle  = Math.min(responsibilityStopAngle, stopAngle);
		$(canvasId).draw({
			layer: true,
			fn: function(ctx) {
				var innerRadius = centerRadial.r - cushionLen;
				if (innerRadius < 0) {
					console.error('cushion length is too large for canvas dimensions');
					innerRadius = 1;
				}
				
				if (ringTable_isDebuggingTable()) {
					ctx.strokeStyle = '#000';
					ctx.strokeWidth = 2;	
				} else {
					ctx.fillStyle = grad;	
				}
				
				ctx.beginPath();
				ctx.arc(centerRadial.x, centerRadial.y, centerRadial.r, minStartAngle, maxStopAngle);
				ctx.lineTo(centerRadial.x - Math.cos(maxStopAngle - Math.PI) * innerRadius, centerRadial.y - Math.sin(maxStopAngle - Math.PI) * innerRadius);  
				ctx.arc(centerRadial.x, centerRadial.y, innerRadius, maxStopAngle, minStartAngle, true);
				ctx.lineTo(centerRadial.x - Math.cos(minStartAngle - Math.PI) * centerRadial.r, centerRadial.y - Math.sin(minStartAngle - Math.PI) * centerRadial.r);
				
				if (ringTable_isDebuggingTable()) {
					ctx.stroke();
				} else {
					ctx.fill();
				}
			}
		});
	}	
} */


			</script>
   </head>
   
   <style>
canvas.canvas1 {
	background: yellow;
}
   </style>
   
<body>
	<h1>Poker Table Showcase</h1>
	<p>Used to test tables of various dimensions and parameters.</p>

	<div id="canvasWithControl1">
		<h2>Basic table 1</h2>
		<p>This shows table were width is longer than height.  The curved ends should appear on the left and right.</p>
	</div>
	<hr>
	<div id="canvasWithControl2">
		<h2>Basic table 2</h2>
		<p>This shows table were height is longer than height.  The curved ends should appear on the top and bottom.</p>
	</div>
	<hr>
	<div id="canvasWithControl3">
		<h2>Round table</h2>
		<p>This shows table if it is a circle.</p>
	</div>
	<hr>
		<div id="canvasWithControl4">
		<h2>Stretched table 1</h2>
		<p>This shows a table with an extremely long width.  Ensures drawing functions are scaling correctly.</p>
	</div>
	<hr>
		<div id="canvasWithControl5">
		<h2>Stretched table 1</h2>
		<p>This shows a table with an extremely long height.  Ensures drawing functions are scaling correctly.</p>
	</div>
	<hr>
		<div id="canvasWithControl6">
		<h2>Small table</h2>
		<p>Ensure we can draw very small tables without hitting errors.  Ensure rail size is proportional.</p>
	</div>
	<hr>	

</body>
</html>